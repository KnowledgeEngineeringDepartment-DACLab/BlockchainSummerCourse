{
  "language": "Solidity",
  "sources": {
    "contracts/YourContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface IERC20 {\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint);\r\n}\r\n\r\ncontract YourContract {\r\n    IERC20 public token;\r\n    uint public tokenReserve;\r\n    uint public ethReserve;\r\n    uint public k;\r\n    constructor(address _token) {\r\n        token = IERC20(_token);\r\n    }\r\n\r\n    // Function to add liquidity to the pool\r\n    function addLiquidity(uint _tokenAmount) public payable {\r\n        uint ethAmount = msg.value;\r\n        if (tokenReserve > 0 && ethReserve > 0) {\r\n            require(ethAmount * tokenReserve == _tokenAmount * ethReserve, \"Invalid ratio\");\r\n        }\r\n        token.transferFrom(msg.sender, address(this), _tokenAmount);\r\n        tokenReserve += _tokenAmount;\r\n        ethReserve += ethAmount;\r\n        k = tokenReserve * ethReserve;\r\n    }\r\n\r\n    // Function to remove liquidity from the pool\r\n    function removeLiquidity(uint _tokenAmount, uint _ethAmount) public {\r\n        require(_tokenAmount <= tokenReserve && _ethAmount <= ethReserve, \"Not enough liquidity\");\r\n        token.transfer(msg.sender, _tokenAmount);\r\n        payable(msg.sender).transfer(_ethAmount);\r\n        tokenReserve -= _tokenAmount;\r\n        ethReserve -= _ethAmount;\r\n    }\r\n\r\n    // Function to swap ETH for Tokens\r\n    function swapEthForTokens() public payable {\r\n        uint ethAmount = msg.value;\r\n        uint tokenAmount = getAmountOut(ethAmount, ethReserve, tokenReserve, k);\r\n        require(token.transfer(msg.sender, tokenAmount), \"Failed to transfer tokens\");\r\n        ethReserve += ethAmount;\r\n        tokenReserve -= tokenAmount;\r\n    }\r\n\r\n    // Function to swap Tokens for ETH\r\n    function swapTokensForEth(uint _tokenAmount) public {\r\n        uint ethAmount = getAmountOut(_tokenAmount, tokenReserve, ethReserve, k);\r\n        token.transferFrom(msg.sender, address(this), _tokenAmount);\r\n        payable(msg.sender).transfer(ethAmount);\r\n        tokenReserve += _tokenAmount;\r\n        ethReserve -= ethAmount;\r\n    }\r\n\r\n    // Function to calculate output amount using x * y = k\r\n    function getAmountOut(uint inputAmount, uint inputReserve, uint outputReserve, uint total) public pure returns (uint) {\r\n        require(inputAmount > 0, \"Invalid input amount\");\r\n        require(inputReserve > 0 && outputReserve > 0, \"Invalid reserves\");\r\n        uint NewInputToken = inputAmount + inputReserve;\r\n        uint NewOutputToken = total / NewInputToken;\r\n        return outputReserve - NewOutputToken;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}